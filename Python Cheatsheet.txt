= Python

:toc:

== Reminder

[cols="m,d"]
|===
| breakpoint()                              | General way for breakpoint
| random.randint(a,b)                       | a<=N<=b
| random.choice(seq)                        | return one element
| locale.setlocale(locale.LC_ALL, "German") |
| a != b                                    | XOR for bool
| @contextlib.contextmanager                | Use on function; "yield" for body
| contextlib.suppress(*excs)                |
| contextlib.redirect_stdout(target)        |
| cls.__bases__                             | Base classes
| PYTHONUNBUFFERED=x                        | "python -h"
| PYTHONIOENCODING=utf8:surrogateescape     |
| PYTHONUTF8=1                              | UTF8 be default everywhere; surrogateescape too
| PYTHOBBREAKPOINT=...                      | Set to callable debugger for `breakpoint()` (or =0 to disable)
| @functools.lru_cache                      | last recently used cache
| str.find()                                | -1 if not found
| str.index()                               | raises ValueError if not founds
| myfunc.__module__                         | module where defined
| sys.setrecursiondepth()                   |
| sys.getsizeof(obj[,default])              |
| operator.itemgetter(item [,args...])      | getitem
| operator.attrgetter(attr [,args...])      | getattr
| try: except: else:                        | executed when no exception, this way you dont protect too many statements with the try clause
| try: except: finally:                     | always executed at end
| from msvcrt import getch                  |
| class A(threading.Thread)                 | For IO bound tasks
| locale.setlocale(locale.LC_ALL, 'deu_deu')    | windows http://stackoverflow.com/questions/955986/what-is-the-correct-way-to-set-pythons-locale
| DictReader(open(filename, newline=""))    |
| # -*- coding: UTF-8 -*-                   |
| getframeinfo(stack()[1][0])               | .lineno .function .code_context   (code line)s
| traceback.print_exc()                     |
| divmod(x,y)                               | (x//y,x%y)
| inspect.getframeinfo(sys._getframe(1), context=0)[2]  | Name of caller
| t=string.Template("apples=$var") +
  t.substitute({"var":"pears"})             | Templates
| s = popen('xsel').read()                  | Copy from clipboard
| os.popen('xsel', 'wb').write(s)           | Paste to clipboard
| obj.__set_name__(self, owner, name)       | Descriptor can now know the variable name
| breakpoint()                              | General breakpoint (Py3.7)
| if (match := ..)                          | Assignment expression (Py3.8)
| open(os.devnull, "w")                     |
| heapq.merge(*its)                         | merge multiple sorted
| sys.settrace(..)                          | Run before function calls/returns/...
| o.__name__                                |
| o.__qualname__                            | Dotted name with full path
| o.__bases__                               |
| o.__class__                               |
| o.__subclasses__()                        |
| isinstance(x, numbers.Real)               | Check for number (int and float)
| open(.., "w", buffering=1)                | Line flush
|===

* object `True` unless `__len__==0`, `__bool__=False`, zero
* most string commands have `start=` and `end=` option
* for set operations `-` is stronger than `|`

== Forgotten

[cols="m,d"]
|===
| {"a", "b"}.__le__                         | Function to check membership
| ascii(..)                                 | return ascii representation and escape special characters
| binascii.hexlify                          | get hex repr of bytes
| bin(...)                                  | convert integer to binary string
| bisect(a,x,lo=0,hi=len(a))                | `a[lo:i]<=x<a[i:hi]`; `a[bisect(a,x)]>x`
| bisect_left(a,x)                          | `a[lo:i]<x<=a[i:hi]`; `a[bisect_left(a,x)]>=x` (next best)
| bisect                                    | x <= a[bisect_right(a, x)-1] <= nextvalue, but check idx=-1; left/right only for exact hitss
| c.most_common()[:-n:-1]                   | n least common
| compile(...)                              | compile code to be executed with exec(...) or eval(...)
| Counter.elements()                        |
| Counter.update                            | updates counts
| defaultdict([fact [,other_dict_args]])    | has __missing__ method
| deque([it,[maxlen]])                      |
| deque.reverse()                           |
| deque.rotate()                            |
| dict.fromkeys(seq, value=None)            |
| dict(iterpairs)                           |
| dict(map)                                 |
| dir(obj)                                  | obj.__dir__() must return strings containing attributes
| functools.singledispatch                  |
| functools.update_wrapper                  |
| insort(a,x)                               | also inserts element (slow O(n) insertion step)
| int([number|string[,base]])               |
| isinstance(a, (t1, t2))                   | check for multiple types
| itemgetter(1,2)(x)                        | get tuple (x[1], x[2])
| iter(obj, sentinel)                       | call obj() and return value; stopiteration if return value equal to sentinel
| list(OrderedDict.fromkeys(items).keys())  |
| locale.strxfrm(string)                    | can be used for local-aware comparison
| median_grouped(data, interval=1)          | bin continous data and interpolate 50%
| median_low()                              | always member of set
| namedtuple._make(it)                      | e.g. map(mynamedtuple._make, cursor.fetchall())
| namedtuple(...,rename=True)               | convert invalid filenames to positional arguments _0, _1, ...
| namedtuple._replace(kwargs)               | make new tuple with some replaced values
| next(it [, default])                      |
| np.logical_and()                          |
| np.ndenumerate(arr)                       | [((x,y), val)]
| OrderedDict.move_to_end()                 |
| pstdev(data, mu=None)                     | give mean if known
| re.compile("[^\W\d_]+", re.UNICODE)       | Alphabetic
| reverse(it)                               |
| seq.count(x)                              |
| seq.index(x[, from[, to]])                |
| seq += ..                                 | same as .extend
| set1 ^ set2                               | xor
| set.__contains__                          | usable as a function
| set.discard(..)                           | Remove if present
| set.intersection_update(other,...)        |
| set.isdisjoint(other)                     |
| set.                                      | Methods usually accept iterators (unlike operators like +=)
| set.remove(..)                            | KeyError if not present
| set.symmetric_difference_update(other,...)    |
| sorted(d, key=d.get)                      | Sort dict by value
| stdev()                                   |
| s.translate(str.maketrans({"a":"A","b":"B","c":None}))    |
| s.translate(str.maketrans("ab","AB","c")) | last argument is optional chars to delete
| str.endswith((s1,s2))                     | true if one of them
| string.ascii_letters                      | "abc...ABC..."
| str.isalpha()                             | Unicode 5 letter categories
| str.isdecimal()                           | For numbers
| str.isprintable()                         | All printable (not Other or Separator) incl. space
| str.isspace()                             | Only whitespaces (Other or Separator)
| str.partition(sep)                        | (head, sep, tail)
| str.rpartition                            |
| str.splitlines                            | No extra empty strings, like with split()
| str.split(sep=None, maxsplit=-1)          |
| str.find(..)                              | -1 if not found
| sum(..., start=...)                       | However consider `join`, `math.fsum`, `chain`
| while: ... else: ...                      | one final statement; skipped by "break"
| ContextDecorator                          | to use CM as decorator
| ExitStack                                 | handle multiple CMs
| with contextlib.redirect_stdout(f)        |
| with suppress(exc)                        |
| str.startswith(("prefix1", prefix2"))     |
| str.*(.., _start_=.., _end_=..)           | Start, end position
| str.replace(.., _count_=..)               | Replace only that often
| str.zfill(_width_)                        | Prepend zeros until width; consider sign too
|===

* `isdecimal` to check for `[0-9]+`;  `isnumeric` for other languages, `isdigit` also does `^2`

== Printing

[cols="m,d"]
|===
| print(.. flush=True)                      | since Py3.3
| "{!a}".format                             | Ascii
| "{:#g}".format                            | g=e+f; Force zeros after dots
| "{0:{1}}".format(a,width)                 | reference other fields also
| "{:%}"                                    | Percent (times 100)
| "{:c}".format(unicode_int)                | Print unicode from number
| "{a[2]}".format(a="123")                  | You can reference sub-elements (but not slices)
| "..".format_map({..})                     |
| chr(i)                                    | Unicode
| "\x..", "\u....", "\U........"            | Different length unicode code point spec
| "\N{snake}"                               | Unicode code point by name
| pprint(obj, stream=None, indent=1, width=80, depth=None) |
| print(*args, sep=' ', end='\n', file=None)    |
| pprint.pformat(...)                       |
| print("\u0336"+"\u0336b".join(word))      | Strike-through
| pprint(..., compact=True)                 | wrap item lists after width only
| "\x1b[01;29m...\x1b[00m"                  | numbers 29-37 (8 colours)
| "{a+b=}"                                  | `print("a+b=", eval(a+b))`
|===

== Math

[cols="m,d"]
|===
| remainder(x, y)                           |
| dist(x, y)                                | Euclidean distance
| hypot(*coor)                              | Euclidean norm
| prod(it, start=1)                         | Product
| isqrt(n)                                  | Floor(Sqrt(n))
|===

== Statistics

[cols="m,d"]
|===
| fmean(data)                               | Mean on floats. Faster than `mean` but not as accurate
| geometric_mean(data)                      | Geometric mean
| multimode(data)                           | List of value which are most frequent (multiple if tie)
| quantile(dist,...)                        | Quantiles https://docs.python.org/3.8/library/statistics.html#statistics.quantiles[Ref]
| NormalDist(mu=0, sigma=1)                 | Normal distribution object https://docs.python.org/3.8/library/statistics.html#statistics.NormalDist[Ref]
|===

== File system

[cols="m,d"]
|===
| exec(open(f).read())                      | exec file
| os.scandir()                              | Dir iteration
| Path.iterdir()                            | Dir iteration
| OSError                                   | Raised by open
| open(.., "x")                             | exclusive creation; raise FileExistsError if file exists
| open(.., "r+")                            | Open for updating
| subprocess.Popen(['xcopy', source, dest]) | option "/Y" for overwrite without asking
| subprocess.Popen(["ls", "-a"])            |
| subprocess.run(.., capture_output=True)   |
| os.path.expanduser("~")                   | Get home
| str(pathlib.Path.home())                  | Get home (Py 3.4+)
| os.getenv("HOME")                         | Get home on Linux
| os.path.getmtime(_path_)                  | Modification timestamp (cross-platform)
| os.path.getctime(_path_)                  | Creation time on Windows; Last modification time on Linux
| os.stat().st_birthtime                    | Creation time on Mac
| path = pathlib.Path(..)                   | Create `Path` object https://docs.python.org/3/library/pathlib.html[Ref]
| path.name                                 | Just filename
| path.parent                               | Directory
| path.parents[1]                           | Directory one level higher
| path.with_name(new_name)                  | New path with filename changed in same directory
| path.with_suffix(suffix)                  | New path with suffix changed
| path.exists()                             |
| path.glob("*.txt")                        | Same directory, `**/*.txt` for sub-directories
| path.rglob("*.txt")                       | Recursively search directories
| f = path.open(mode="r")                   | Open file https://docs.python.org/3/library/pathlib.html#pathlib.Path.open[Ref]
| path.read_text(encoding=None)             | Read decoded text https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text[Ref]
| path.write_text(data)                     | Open, write text and close https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text[Ref]
| f.writelines(iter)                        | Write multiple string; you need to include line separator yourself
|===

On Linux no creation time accessible, so use `os.path.getmtime()` or `os.stat().st_mtime` which is modification time. Creation time should be `os.stat().st_crtime` but currently not supported.

* `subprocess(.., shell=False)` better for security; helper `shlex.split()` useful

== Data method model

[cols="m,d"]
|===
| __getstate__                              | for custom pickle return dict to store
| __length_hint__                           | return estimated length of sequence; purely for optimization, e.g. pre-alloc lists
| __round__                                 |
| __reversed__                              |
| __getattribute__                          | called
| __getattr__                               | only when missing?
| __index__                                 | used for bin(), oct()... or fallback when no `__float__` etc.
| __trunc__                                 | real truncate
|===

== Pickle

* Name namedtuple same as variable name to make in picklable or have at least A=myname=namedtuple("A", ...)
* often pickle.DEFAULT_PROTOCOL < pickle.HIGHEST_PROTOCOL
* Protocol 4 (HIGHEST, from Python 3.4) 10% faster [but not much?] and slightly smaller than Protocol 3 (Default Python 3)
* Feather can be much faster for DataFrames (?), but does not support index

== Libraries

* array: arrays for numeric values
* atexit: hook at exit of the interpreter
* calendar
* cmd: command line prompt
* code: interpreter (e.g. code.interact())
* cProfile: profiling info
* difflib: compute deltas
* filecmp: file and dir compare
* fileinput: loop over files given in sys.argv
* formatter: interface for text layout (paragraph, font,...)
* fractions
* getpass: password input
* io: abstract file access (raw, buffered, text)
* linecache: random access to lines in file
* reprlib: more custom repr
* runpy: run python modules in python search path
* shlex: lexical token analyzer for parsing a simple unix like language
* shutils: file operations
* struct: interpret bytes as packed data
* textwrap
* timeit: time on single small command
* trace: determines dynamically how often each line of code is executed
* unicodedata: unicode info
* weakref: reference that do not count for garbage collection block (e.g. for circular references)
* secrets:


== Type annotations

    a : a_type = a_val


== Regex

[cols="m,d"]
|===
| re.finditer(regex, text)                  |
| re.fullmatch()                            | to match full string only
| re.split(regex, text, maxsplit)           |
| regex_match.group(.., ..)                 | multiple -> returns tuple
| regex_match.expand(template)              |
| regex_match.groupdict()                   |
|===

== Math

[cols="m,d"]
|===
| complex("1+2j")                           |
| float.as_integer_ratio()                  |
| float.fromhex()                           |
| float.hex()                               | Gives exact machine value
| float("-inf")                             |
| float("+inf")                             |
| float.is_integer()                        |
| float("nan")                              |
| hypot(a, b)                               | sqrt(a*a+b*b)
| int.bit_length()                          |
| int.from_bytes(...)                       |
| int.to_bytes(...)                         |
| math.copysign(magn, signvar)              |
| math.expm1(x)                             | e**x-1
| math.frexp(x)                             | split into (m, e) such that x=m * 2**e
| math.fsum()                               | for floating point
| math.isclose(a,b)                         | abs(a-b)<=max(rel_tol*max(abs), abs_tol) (Python 3.5)
| math.isfinite(x)                          | Not inf or NaN
| math.isinf(x)                             |
| math.isnan(x)                             |
| math.ldexp(x, i)                          | x * (2**i); inverse is math.frexp()
| math.log1p(x)                             | ln(x+1)
| np.seterr                                 | set what to do when floating point errors (but pandas will overwrite)
| np.array_equal()                          |
| round(1234,-2)                            | 1200
| round(x [,digits])                        |
| sys.float_info.dig                        | How many decimals always exact (float ~15.9 digits)
|===

Usually wrapper around platform C math library. ValueError or OverflowError. NaN only when arguments NaN.

* `int(float(1e16+1))` will truncate the first time

== Functional

[cols="m,d"]
|===
| map(func, it1, it2, it3)                  | func(it1[0], it2[0], it3[0]), func(it1[1],...),...
| compress('ABCDEF', [1,0,1,0,1,1])         | A C E F
| dropwhile(lambda x: x<5, [1,4,6,4,1])     | 6 4 1
| takewhile(lambda x: x<5, [1,4,6,4,1])     | 1 4
| filterfalse(lambda x: x%2, range(10))     | 0 2 4 6 8
| filterfalse([1,2].__contains__, l)        | remove elements
| starmap(pow, [(2,5), (3,2), (10,3)])      | 32 9 1000  # like map but does unpacking
| functional.compose(f1,f2 [unpack=True])   | concatenate functions
| functional.foldl(...)                     | creates f(f(f(.,.),.),.)
| filter(None, iterable)                    | use identiy function, i.e. remove False
| functools.reduce(func, iter [,init])      |
|===

== Regex

https://docs.python.org/3/library/re.html#regular-expression-syntax[Python Regex Syntax]

[cols="m,d"]
|===
| [^\W\d_]                                  | for alpha only
| (?<!                                      | Negative look-behind
| (?!                                       | Negative look-ahead
| (?:                                       | non capturing
| (?i)                                      | ignore case (see also options for more)
| (?<name>                                  | named group
| \1                                        | match first group
| \b                                        | word boundary
| \A \Z                                     | start end
| \d (\D)                                   | digit (not)
| \s (\S)                                   | whitespace (not)
| \w (\W)                                   | word: letters, numbers, underscore (not)
| re.DEBUG                                  | info
| re.I                                      | ignorecase
| re.M                                      | multiline (^$ match all line start/end)
| re.S                                      | "." will match newline too
| re.X                                      | ignore whitespace and comments after (for readability)
|===

* could not find clear performance benefit of `(?:`
* difference between matching and searching
* can provide index to offset match but matching itself will be anchored
* -> useful for lexers (can still use ^ for beginning of line)
* scanner to efficiently search for multiple
** re.Scanner class (undoc)
** look at source code to extend (see stored article)

== Time

=== Conversion

[cols="m,d"]
|===
| ts = date.timestamp()                     | float (from platform mktime())
| date = dt.datetime.fromtimestamp(ts)      | from time.time() timestamp
| _pdts_ = pd.Timestamp(_dt_)               |
| _dt_ = _pdts_.to_pydatetime()             |
| _date_ = _pdts_.date()                    |
| _datetime_ = dt.datetime.combine(time, dt.datetime.min.time())    |
|===

    sec_since_midnight
       = (dti-dti.normalize())/pd.Timedelta("1s")   # For DateTimeIndex
       = (dt.datetime.combine(datetime.min, t)-datetime.min).total_seconds()  # For time object

Timestamp is UTC seconds since seconds since 1970-01-01 00:00. Hence
dt.datetime(1970,1,1,0,0,tzinfo=pytz.timezone("CET")).timestamp() = -3600
(this tzinfo is also used for default!)
for "UTC" you would get 0

Timedelta multiplied by float is rounded to timedelta resolution.

Pandas timestamps are 64bit nanoseconds, hence they only work years 1678-2261.

https://stackoverflow.com/questions/13703720/converting-between-datetime-timestamp-and-datetime64


=== Other

[cols="m,d"]
|===
| "{:%Y-%m-%d}".format(datetimeobj)         | object can support own formatting by __format__
| date.replace(year,month,day)              |
| dt.timedelta.total_seconds()              |
| dt.datetime.utcnow()                      | date+time tzinfo as None
| date.today()                              | today
| dateutil.relativedelta(years=, months=)   | for all parameter specs https://labix.org/python-dateutil
| calendar.month_abbr[i]                    |
| calendar.month_name[i]                    |
| calendar.monthrange(year, month)          | (weekday, numdays)
| date.isoweekday()                         | Mon=1, Sun=7
| date.isocalendar()                        | year/week/weekday
| date.isoformat(" ")                       | YYYY-MM-DD HH:MM:SS (char is separator; default "T")
| date.strptime(datetext, format)           | Parse time
| dt.strftime(format)                       | Format time
| format="%x"                               | Locale date(?)
| date.ctime()                              | longer string with weekday etc.
| time.monotonic()                          |
| np.is_busday(.., busdaycal=..)            |
| CDay(holidays=[..]).calendar              |
| time.gmtime(0)                            | Start of epoch
| time.ctime()                              | String of current time
| time.ctime(epoch_secs)                    | String of given time
|===

=== Formatting

https://docs.python.org/3.4/library/datetime.html#strftime-and-strptime-behavior[Time formatting]

[cols="m,d"]
|===
| %a                                        | weekday name
| %w                                        | weekday number (0=Sun)
| %d %m %y                                  | day, month, year
| %H %M %S                                  | hour, minute, second
| %f                                        | microseconds
| %W                                        | weeknumber of year
| %c                                        | date+time in locale
| %x %X                                     | date, time in locale
| %%                                        | percent sign
|===

=== Time zones

[cols="m,d"]
|===
| datetime.utcnow()                         | Timezone naive current time in UTC timestamp
| _dttz_ = _dt_.replace(tzinfo==pytz.timezone("UTC"))   | Make UTC time timezone aware (use this only for UTC!)
| tz = pytz.timezone("..")                  | Create timezone object
| tz = pytz.utc                             |
| pytz.utc                                  | UTC timezone
| _tzdt_=_tz_.localize(_dt_)                | Adds timezone to tz-naive datetime (always use this if not UTC)
| _tztime_=_tzdt_.astimezone(_tz_)          | Convert timezone
| _normtztime_=tz.normalize(_tztime_)       | ?
| pytz.utc.localize(dt.datetime.utcnow()).astimezone(pytz.timezone("Europe/Berlin"))    |
| _dt_.timestamp()                          | Yields UTC timestamp, but uses local timezone if _dt_ is tz naive
|===

Convert timezone naive UTC times as late as possible for the user.
In `dateutil.tz` only `tzlocal()` and `tzutc()`. Never use `mydate.replace(tzinfo=tz)` (https://www.reddit.com/r/Python/comments/2wd35a/pytz_timezone_fun/).
Always store in UTC. `calendar.gmtime()` is also a time function. Use "GMT" timezone string for `strptime`.
Use ISO8601  for string format.

Alternatives

* arrow
* pendulum
* delorean
* mxdatetime

== Generator

    def func(...):
        ...
        val=yield result     # None if only next() called; use (yield ...) if not isolated statement

    func.next()
    func.send(val)
    func.throw(..)         # exception in generator
    func.close()           # raises GeneratorExit in generator -> generator should raise GeneratorExit or StopIteration

== Profiling

* some save in "callgrind" format -> use viewer (e.g. KCacheGrind)
* https://rivolaks.com/posts/profiling-python/

=== Built-in cProfile

    p = profile.Profile()
    p.enable()

    try:
        ...
    finally:
        p.disable()
        pstats.Stats(p).sort_stats('cumulative').print_stats(30)

* but slow

=== Yappi

    yappi.start()

    try:
        ...
    finally:
        func_stats = yappi.get_func_stats()
        func_stats.save('callgrind.out.' + datetime.now().isoformat(), 'CALLGRIND')
        yappi.stop()
        yappi.clear_stats()

== Pyflame

* https://pyflame.readthedocs.io/en/latest/[PyFlame]
* from Uber; external agent
* only Linux
* nice with Docker
* statistical profiler: less overhead since check call stack on at fixed intervals (e.g. 1000/sec)

== Windows

vcvarsall.bat
run Python in cmd, check MSC_VER=
Visual C++ 2008                 MSC_VER=1500
Visual C++ 2010                 MSC_VER=1600
Visual C++ 2012                 MSC_VER=1700
Visual C++ 2013                 MSC_VER=1800
http://blog.ionelmc.ro/2014/12/21/compiling-python-extensions-on-windows/
Install Visual C++ Express (http://download.microsoft.com/download/1/D/9/1D9A6C0E-FC89-43EE-9658-B9F0E3A76983/vc_web.exe)
Prob need Windows SDK too (http://www.microsoft.com/en-us/download/details.aspx?id=8279)
https://www.microsoft.com/en-us/download/details.aspx?id=4422
https://www.microsoft.com/en-us/download/confirmation.aspx?id=23691
Remove all VC++ 2010 Redistributable

== Pythons

=== Python 3 only:

* ! matrix operator
* adv. unpacking
* keyword only arguments
* chained exceptions
* fine grained OSError subclasses
* everything is iterator (e.g. range)
* ! incompatible classes don't compare anymore
* yield from
* asyncio
* ! enum type
* function annotations

* If encoding error on pickle.load with Python 3 on Python 2 files -> use pickle.load(..., encoding="latin1")

=== Python 3.4

* enum
* type.__locallookup__ (for dynamic)
* single-dispatch generic funcs
* additional unpacking
* stats
* pip not included but can be installed easy
* new GIL in 3.2 (otherwise problems with multiple cores)
* key sharing dict
* yield from
* fast decimal module
* pyc dead; __init__.py dead (namespace packages); virtualenv built-in
* Windows launcher; good for multiple versions; also read shebang line
* list.copy(); contextlib.ExitStack
* types. SimpleNamespace
* setuptools and distribute merge
* wheel for binary install (for installing binaries)

=== IronPython

* no GIL
* for .NET
* 2.7

=== Jython

* small team
* no GIL
* 2.7 is beta

=== PyPy

* GIL
* ARM support
* beta for 3.2
* Numpypy
* 2 projects:
  * translates RPython code into executable (or JVM, ...); add greenlets, stackless, ...
  * implementation of Python written in RPython
* software transactional memory (strategy to get rid of GIL); divide program into chunks

== Numba

* Numpy + Subset Python + LLVM
* just by decorator
* bypass GIL

== Blaze

* data to code seamlessly
* solution indep of storage format (HDF5, SQL, CSV, ...)
* compute abstraction (pandas, DyND, spark, ...)
* Blaze expression graph

== Forking

* only Linux/Unix
* process clones itself and one changes behavior

    newpid=os.fork()
    if newpid==0:
       # child code
    else:
       # parent code

== GIL

Put most simply, Python doesn't "interpret Python bytecode" in parallel. It *does* run its threads in parallel and there are plenty of good reasons to use them. Specifically:

1. The GIL isn't held when you're blocked on the OS. If your code spends a lot of time waiting on the system, then the GIL doesn't hurt you because you're not interpreting Python bytecode.
2. The GIL isn't held when Python is doing work inside of a single instruction. If you're manipulating large strings, doing large bit operations, etc. then the GIL doesn't hurt you, because these things happen in-between the bits of bytecode.
3. The GIL isn't held when you're running code in C extensions. Numpy, Python Image Library, and many other commonly-used extensions don't hold the GIL, so they don't hurt you.
4. If you're really, really dependent on some piece of Python code, Cython allows releasing the GIL using a with-statement.
5. If you're not tied to C extensions, Jython and IronPython don't have a GIL.
6. Depending on your needs, PyPy has often increased performance enough that previously GIL-bound applications were tractable. (Note that it still has its own GIL, it's just faster.)

There is subtlety in how the GIL is synchronized between threads. Similarly, Multiprocessing copies objects unless you use the shared-memory functionality. Depending on how you write your app, you may find that it's now parallel, using multiple cores, and still not much more productive.
"The GIL makes Python single-threaded, use multiprocessing." is really only the beginning of writing efficient concurrent applications in Python. Understand the GIL, understand multiprocessing, get good at benchmarking, learn to profile, maybe even learn the disassembler, automate your test environment, etc. There's no substitute for understanding...

== Generators

    def func(...):
      ...
      val=yield result     # None if only next() called; use (yield ...) if not isolated statement

    func.next()
    func.send(val)
    func.throw(..)         # exception in generator
    func.close()           # raises GeneratorExit in generator -> generator should raise GeneratorExit or StopIteration

"yield from" needed for two-way communication (pass .send values and exceptions through; handle StopIteration or when outside loop closed)

yield/send:
before send() there must be at least one next()
send() function restarts generator and also returns new value like next()

    def generator():
        ...
        next_val=(yield val)

    g=generator()
    a=g.next()
    b=g.next()
    g.send(new_next_val)                    # talk back to generator
    g.throw(<exceptiontype>,...)                # raise exception in generator
    g.close()                       # closes generator

== Enums

* attributes have names and int values
* singletons
* not normal Python classes
* iteration in definition order
* generate by name Color["RED"] -> Color.RED
* support "is" and comparison
* classes can have additional methods
* IntEnum can be compared to ints
* Flags can be combines with bitwise operators
* programmatically: Enum("Color", "Blue Yellow Red") # or similar to namedtuple, e.g. sequence
* always compare False to non-enum; do not throw errors!

== Tools for Python code

* https://github.com/ofek/hatch[hatch]: Modern replacement for Virtualenv/Cookiecutter/...

== Data Model

* `iter(obj)`: uses `__iter__` or `__getitem__` starting at 0
* `hasattr`: calls `getattr` and checks exception
* non-identical classes unequal unless `__eq__`
* inside `__setattr__` use `self.__dict__[name]=`
* Python `.sort` is guaranteed to use `__lt__`
* can overwrite `dict.__missing__` in subclass


== Mathematics

* complex supports signed zeros (preserves sign)
* Python use Karatsuba multiplication for large numbers
* Division not so fast, but Newtons algorithm can help
* int infinite precision
* repr(float_num) is shortest string which when converted to float returns original value -> str version and exact numeric value is bijection; before it was longer (http://stackoverflow.com/questions/28493114/precision-of-reprf-strf-printf-when-f-is-float/28493269[since Python 3.1])

== Programming quality

`radon mi *.py` to measure maintainability class http://radon.readthedocs.io/en/latest/intro.html
But does not measure function length etc. Didn't find any better https://github.com/mre/awesome-static-analysis.

== Extended features

* Counter: can have negative counts; supports binary operations
* Order of dict key/values access stable so zip(d.values(), d.keys()) possible

== I/O specials

* default open() encoding locale.getpreferredencoding(False)
* os.linesep used in writing of files
* `shutil.copyfile` slow on Windows/Mac
* mutable string: StringIO or array
* memoryview type -> access to objects that support buffer (e.g. bytearray)
* open file in text mode -> python shows \n instead of the windows \r\n or \r or \n
* \x1e us group separator (see str.splitlines)
* builtin memoryview to have mutable data space applicable on any buffer protocol object

== Optimizations internals

* object attr __dict__ can reuse key memory (PEP412)
* dict.setdefault does only one lookup
* set() is now singleton if in code?
* since Python 3.6 dicts are ordered (and 20% smaller) by default (https://docs.python.org/3.6/whatsnew/3.6.html#new-dict-implementation)

== Calling Python

* PEP370: user site packages for linux and windows
* Windows: user site-packages in %APPDATA%/Python
* `__main__.py` executed if directory or zip
* -O option: current removes only assert()
* -OO option: current only removes extra docstring
* python -m zipapp mymod; python mymod.pyz
* new UTF8 mode in https://www.python.org/dev/peps/pep-0540/[Python 3.7]:
** utf8 used irregardless of locale; stdin/stdout to surrogateescape
** activated with POSIX locale
** activated with `-X utf8` option or `PYTHONUTF8` env

== Import specials

* `from .[mod] import name`   -> only way for relative import
* `import *` not possible in function
* __init__ contains __all__=[...] -> only this imported with "import *"

== Other

* abstract bases classes for data structures: https://docs.python.org/3/library/collections.abc.html#module-collections.abc (see https://docs.python.org/3/glossary.html#term-abstract-base-class for more)
* dt.fromtimestamp(utc_number) will use local timezone
* time "epoch" is universal everywhere
* SAS format: `lambda x:dt.datetime.strptime(x, "%d%b%Y")`
* for numbers to be equal, their hash has to be equal; Python internal hash is stored (sys.hash_info, a prime, see reference stdtypes)
* Priorities: numeric, bitwise, comparison, not, and, or
* default args evaluated at function _definition_ (i.e. what defined at the point)
* collections.UserDict, collections.UserList, collections.UserString: easier subclassing since data accessible by .data
* list comprehension list that is being built is _[...]
* True and False behave like 1 and 0 in numeric context
* operator version (+=) takes only sets; function version (.union) takes any iterator
* to define setters and getters for an attribute use the reserved function property(...)
* class variables __var are renamed to _class__var so that subclasses dont clash
* namedtuple.var.__doc__="..."
* dicts and variable assignments (depend on dict) arent always atomic (e.g. __hash__ and __eq__ are Python functions)
* dict.keys() and .items() is set-like
* collections._chain # undocumented
* range bigger sys.maxsize permitted but raise OverflowError on len()
* hash(-1)=hash(-2)=-2!
* binary ops on set/frozenset return first type
* `defaultdict.default_factory`: writable
* number hash() are equal when number equal
* scopes: local, enclosing functions, global modules scope, built-in
* PYTHONUNBUFFERED=x or "python -h" r sys.stdout.flush()
* `numexpr.test()`
* `bottleneck.test()` -> 79 tests in 70.712s OK run=79 errors=0 failures=0
* get BLAS info: `numpy.distutils.system_info.get_info('blas')` could also be atlas
* to restore built-ins: `del myoverwritten` or `import builtins; real=builtins.real`
* ` -X utf8` to force utf8 independent of locale

== Anaconda

    while read requirement;
        do conda install --yes $requirement || pip install $requirement;
    done < requirements.txt

== Unsorted
class my_nt(NamedTyple)   # Python 3.6

or dataclasses in Python 3.7

JSON worse than YAML since tuple and list become same encoding

Performance:
* creating lists has small overhead compared to tuples, so creating small tuples faster than small lists; but apart from that tuples are not faster

Pickling namedtuple:
* can be useful to programmatically generate namedtuple for dicts when keys often the same
* create these types in top-level namespace (`globals().update(...)`)
* store spec (name, fields) also
* pickle data
* to load: recreate types from specs on top-level, load pickle

    from collections import namedtuple
    types=pickle.load(open("types.pkl", "rb"))
    globals().update({name:namedtuple(name, fields) for name, *fields in types})

++++++++

dt.datetime.now(pytz.timezone("Europe/Berlin"))

def __getattribute__(self, item):
  if item in self.__class__.__dict__:
    v = self.__class__.__dict__[item]
  elif item in self.__dict__:
    v = self.__dict__[item]
  else:
    v = self.__getattr__(item)
  if hasattr(v, '__get__'):
    v = v.__get__(self, type(self))
  return v

  
Numpy implements buffer protocol:
Could make arrays immutable with `ndarray.flags.writeable`
StaticFrame (pypi static-frame) manages an immutable Pandas DataFrame