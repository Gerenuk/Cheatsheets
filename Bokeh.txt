= Bokeh

== Interface levels

* low-level `bokeh.models` for developers
* mid-level `bokeh.plotting` for composing visual glyphs (http://bokeh.pydata.org/en/latest/docs/user_guide/plotting.html#userguide-plotting)
* high-level `bokeh.charts` for plots (http://bokeh.pydata.org/en/latest/docs/user_guide/charts.html#userguide-charts)

Models:

* input is collection of JSON objects for scenegraph
* -> converted into Backbone models and rendered by Backbone views
* Python library generates JSONs (mirrored model classes exposed and match backbone models; validate and serialize)

== Basic plotting

* `output_file()` to determine destination; `output_notebook()` for Jupyter; `output_server()` for Bokeh Server
* `figure()` to create plot (`Figure()`) with options (title, tools, ...)
* add renderer (e.g. `.line()`) (color, legend, ...)
* `show()` or `save()`

Bokeh examples use sample data which can be downloaded with `bokeh sampledata`

To reuse matplotlib plot (many plots work) do

    from bokeh import mpl
    from bokeh.plotting import output_file, show
    ...
    output_file(..)
    show(mpl.to_bokeh())

== Components

* Glyphs; have line/fill/text properties
* Guides (grid lines, axes, log, ...)
* Annotations (label parts of plot, titles, legends, ...)
* Ranges (axis limits, simplest is just tuple)
* Document: organizing data structure of running Bokeh application
* Models: lowest-level objects that comprise "scenegraphs" (all plots collection of models)

For plotting client library BokehJS and CSS code must be loaded into browser (default will load from http://cdn.pydata.org).
Use `output_file(.., mode="inline")` to generate file with BokehJS embedded.

Convenience argument `color` and `alpha` set values for both `line_*` and `fill_*`.
To link elements (like axis limit), reuse same object (`figure(..., x_range=fig1.x_range)`)
To combine plots to multiple, use `p = gridplot([[f1, f2, f3]])`.
For brushing use `source = ColumnDataSource(data={"col1":arr1, ..})` and specify plot as `.line("x", "y", source=source)`.
For date axis `DatetimeAxis` will be used automatically (or pass `x_axis_type="datetime"`).
You can customize the plot by setting attributes (e.g. `p.title.text=".."`).

== Bokeh server

* UI widgets and plot selections driving computations and plot updates
* down-sampling of large data
* streaming data
* glyph re-writing and transformations
* plot and dashboard publishing
* examples: http://bokeh.pydata.org/en/latest/docs/gallery.html#gallery-server-examples
* running a server: http://bokeh.pydata.org/en/latest/docs/user_guide/server.html#userguide-server

== Command line
See http://bokeh.pydata.org/en/latest/docs/user_guide/cli.html#userguide-cli

* `bokeh html`: create standalone HTML
* `bokeh json`: create serialized JSON
*  `bokeh serve`: publish interactive

can create plot from sources (python script, app directory, JSON, ...). Therefore don't need `show()` in code, but can determine later.

== Glyph plotting

|===
| p.circle(x_arr, y_arr, radius=_dataunits_) | Scatter plot with circles
| p.square(x_arr, y_arr, ..) | Scatter plot with squares
| x=, y=, size=, angle=      | Common glyph parameters
| p.line(x_arr, y_arr, ..)   | Line plot
| p.multi_line([x_arr1, y_arr1], [x_arr2, y_arr2], ..)  | Multiple line segments (with same styling)
| float("nan")               | break in line
| p.patch(x_arr, y_arr, ..)  | Polygonal patch
| p.patches([x_arr1, y_arr1], [x_arr2, y_arr2], ..)  | Multiple patches
| p.quad(top=[..], bottom=[..], left=[..], right=[..], ..) | Axis aligned rectangle
| p.rect(x=[..], y=[..], width=.., height=.., angle=.., height_units="screen") | Arbitrary rotated rectangle
| p.ellipse(..) | Ellipse with same parameter names as `p.rect()`
| p.oval(..) | Oval with same parameter names as `p.rect()`; different from ellipse, does not generate circles
| p.image() +
  p.image_rgba() +
  p.image_url() | Display images
| p.segment(x0=[..], y0=[..], x1=[..], y1=[..], ..) | Line segments
| p.ray(x=[..], y=[..], length=.., angle=.., ..) | Directed line segments
| p.arc(x=[..], y=[..], radius=.., start_angle=.., end_angle=.., ..) | Arc of a circle
| p.wedge(..) | Filled arc of a circle
| p.annular_wedge(.., inner_radius=.., outer_radius=..) | Annular filled wedge
| p.annulus(.., inner_radius=.., outer_radius=..) | Closed, filled annular
| p.quadratic() +
  p.bezier() | Parametrized curves
| legend=".." | To create legend
|===

== Plot properties

|===
| x_range, y_range | Plotting range (tuple, `Range1d()`, ...)
| x_range=["a", "b", ..] | Categorical axis
| x_axis_type="log" | Log scale
| title=..  | Plot title; to change it's style, set it's attributes
|===

== Add Layout objects

|===
| Title(..) | Alternative way
| Arrow(..) | Add arrow
| BoxAnnotation(..) | Make highlighter box
| Label(..) | Add glyphs or plot regions
| Span(location=.., dimension=..) | Single horizontal or vertical line
|===

Twin axis with

    p.extra_y_ranges = {"name" : ..}
    p.line(.., y_range_name="name")
    p.add_layout(LinearAxis(y_range_name="name"), "left")

== Charts

Use `from bokeh.charts import *`. Set defaults with

   from bokeh.charts import defaults
   defaults.width=..
   defaults.height=..

Accepts
Table:

* pd.DataFrame (also used internally)
* Blaze
* list(dict), dict(list)

Array

* list, tuple
* np.ndarray
* pd.Series

`AttrSpec`: look-up from unique data label to chained iterable.

|===
| Bar(df, label=.., values=.., agg="sum") | Bar chart
| agg in sum, mean, count, nunique, median, min, max | Bar chart aggregations
| bar_width=_percentOfCategory_ | Bar width
| group=.. | Visual grouping
| stack=.. | Stacking
| BoxPlot(df, values=.., label=.., ..) | Boxplot
| color=.., whisker_color=.. | Set Boxplot color
| outliers=False | Turn off outlier display
| marker=.. | Set outlier marker
| Histogram(arr, bins=50) | Histogram
| Histogram(df, values=..) | Histogram on column
| color=_col_ | Group by this column and make histogram for all groups
| Scatter(df, x=.., y=.., col=..) | Scatter plot
| color=_col_, marker=_col_ | Group by this column and make scatter for all groups
|===

Use `legend="top_left` for positioning and `legend_sort_field=..` /`legend_sort_direction=..` to sort.
You can group on

== Other libraries

Holoview provides even easier prototyping in Jupyter

== Styling

Palettes from `from bokeh.palettes import ..` support Brewer.
Colors:

* CSS colors (http://www.w3schools.com/colors/colors_names.asp)
* #RRGGBB, #44444444
* (r,g,b), (r,g,b,a); use with `bokeh.colors.RGB(..,..,..)` to pass

Positions in screen units (pixel) or data-space units.

To get plot objects (other than accessing by attribute) use `p.select(..)` (search parameters for type, name, ...).
Dimensions with `p.plot_height` and `p.plot_width`. `p.responsive` to fill (web) container the plot is in.
You can also set:

* background
* border style and width
* plot outline (box)

To change glyphs get renderer with `r=p.circle(..); r.glyph`
Styling of (non)selected can be set with `selection_glyph`/`nonselection_glyph` attribute.
Just the color/alpha or (non)selection can be set with normal color attributes and prefix `(non)selection_..`.

Use `hover_..` prefix attributes to set hover style.

Tools may have `.overlay` attributes where you can set style.

== Axis

|===
| p.xaxis, p.yaxis | Get axis objects; will affect all; for e.g. ticker select on particular
| .axis_label | Axis label
| .bounds | Limit where axis is actually shown
| .ticker | Choose ticker (`from bokeh.models`)
| .formatter | Tick formatter
| .major_label_orientiation="vertical" | Label orientation
| NumeralTickFormatter, PrintfTickFormatter | For fine-grained control
| FuncTickFormatter(code="..) | Supply Javascript or Coffeescript
| p.yaxis.formatter=FuncTickFormatter.from_py_func(_pyfunc_) | To use Python function
|===

== Grid

|===
| p.grid, p.xgrid, p.ygrid | Return Grid object
| .band_fill_color | Shaded bands between grid lines
| .bounds | Set bounds where grid is drawn
|===

|===
| p.legend
| p.add_layout(Legend(..), location=..) | To create outside plot
| .orientation | Orientation of item list in legend
|===

== Tools

* Gestures: always only one of Pan/Drag, Click/Tap, Scroll/Pinch
* Actions: activated by button
* Inspector: passive, report information of annotate

Lowest level:

   plot = Plot()
   plot.add_tools(LassoSelectTool())

Higher level:

   figure(.., tools=[BoxZoomTool()])
   figure(.., tools="pan,wheel_zoom")
   f.add_tools(..)

Multi-select with SHIFT. Cancel with ESQ.
Zoom can be restricted to one axis only.

Hover tool:

* names with "@" are columns in data source
* names with "$" are special (e.g. x coordinate)

    from bokeh.plotting import figure, output_file, show, ColumnDataSource
    from bokeh.models import HoverTool

    source = ColumnDataSource(data=dict(x=[..], y=[..], desc=[..]))
    hover = HoverTool(tooltips=[
                ("index", "$index"),
                ("(x,y)", "($x, $y)"),
                ("desc", "@desc"),])
    p = figure(.., tools=[hover])
    ..

Also possible to pass custom HTML as tooltip.

=== Level of Detail
Show only fraction of data during interactive operations (e.g. panning). Attributes `lod_factor`,
`lod_interval`, `lod_threshold`, `lod_timeout`.
