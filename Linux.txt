Cinnamon:
* from GNOME2
* from Linuxmint
* edge tiling and snapping
* lightweight

Unity:
* for GNOME optimize screen space for touchscreens
* Dash search scope with Lenses

Pantheon:
* elementaryOS
* no fork; GTK3
* clean, modern
* grid window tiling
* light

Other:
* LXDE: super light-weight
* XFCE: light, GTK2+, simple
* Trinity: KDE3
* MATE: GNOME2, light

Tiling:
http://www.slant.co/topics/390/~what-are-the-best-window-managers-for-linux

i3:
* poor floating, manual tiling, no window gap

awesome:
* http://www.slant.co/topics/390/viewpoints/2/~what-are-the-best-window-managers-for-linux~awesome

dwm: too light
xmonad:
* needs Haskell knowledge

git push origin master

htop:
"task"="process"
Memory: Green used, Blue buffers, Orange cache
VIRT: requested memory incl memory mapped files (not useful?)
RES: currently in memory (hence without swapped; incl shared memory with others)
SHR: potentially shared memory

Uninterruptable processes are USUALLY waiting for I/O following a page fault. The process/task cannot be interrupted in this state, because it can't handle any signals; if it did, another page fault would happen and it would be back where it was.

A niceness level increase by 1 should yield a 10% more CPU time to the process


Execution:

Interactive + Login:
1. /etc/profile
2. .bash_profile OR .bash_login OR .profile
3. on exit: .bash_logout

Interactive w/o Login:
1. .bashrc

Non-interactive
1. $ENV

while read $var; do echo "$var"; done
gawk '{print $3}'


Git:
List file conflicts

git diff --name-only --diff-filter=U
git ls-files -u

Merge:
git mergetool
git checkout --ours <file>
git checkout --theirs <file>
git add <file>
git commit ...
git pull
